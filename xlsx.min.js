(function (global) {
  'use strict';

  const encoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
  const decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;

  function encodeUTF8(input) {
    if (input instanceof Uint8Array) return input;
    if (encoder) return encoder.encode(String(input));
    const utf8 = unescape(encodeURIComponent(String(input)));
    const result = new Uint8Array(utf8.length);
    for (let i = 0; i < utf8.length; i += 1) {
      result[i] = utf8.charCodeAt(i);
    }
    return result;
  }

  function decodeUTF8(buffer) {
    if (typeof buffer === 'string') return buffer;
    if (decoder) return decoder.decode(buffer);
    let string = '';
    for (let i = 0; i < buffer.length; i += 1) {
      string += String.fromCharCode(buffer[i]);
    }
    return decodeURIComponent(escape(string));
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const tbl = new Uint32Array(256);
      for (let n = 0; n < 256; n += 1) {
        let c = n;
        for (let k = 0; k < 8; k += 1) {
          c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
        }
        tbl[n] = c >>> 0;
      }
      return tbl;
    })());
    let crc = -1;
    for (let i = 0; i < buf.length; i += 1) {
      const byte = buf[i];
      crc = (crc >>> 8) ^ table[(crc ^ byte) & 0xff];
    }
    return (crc ^ -1) >>> 0;
  }

  function concatUint8(chunks) {
    let total = 0;
    for (const chunk of chunks) {
      total += chunk.length;
    }
    const result = new Uint8Array(total);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }

  function toUint8(arrayBuffer) {
    return arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
  }

  function createZip(entries) {
    const localParts = [];
    const centralParts = [];
    let offset = 0;
    entries.forEach((entry, index) => {
      const nameBytes = encodeUTF8(entry.name);
      const dataBytes = encodeUTF8(entry.data);
      const crc = crc32(dataBytes);
      const localHeader = new Uint8Array(30);
      const localView = new DataView(localHeader.buffer);
      localView.setUint32(0, 0x04034b50, true);
      localView.setUint16(4, 20, true);
      localView.setUint16(6, 0, true);
      localView.setUint16(8, 0, true);
      localView.setUint16(10, 0, true);
      localView.setUint16(12, 0, true);
      localView.setUint32(14, crc, true);
      localView.setUint32(18, dataBytes.length, true);
      localView.setUint32(22, dataBytes.length, true);
      localView.setUint16(26, nameBytes.length, true);
      localView.setUint16(28, 0, true);

      const localRecord = concatUint8([localHeader, nameBytes, dataBytes]);
      localParts.push(localRecord);

      const centralHeader = new Uint8Array(46);
      const centralView = new DataView(centralHeader.buffer);
      centralView.setUint32(0, 0x02014b50, true);
      centralView.setUint16(4, 20, true);
      centralView.setUint16(6, 20, true);
      centralView.setUint16(8, 0, true);
      centralView.setUint16(10, 0, true);
      centralView.setUint16(12, 0, true);
      centralView.setUint16(14, 0, true);
      centralView.setUint32(16, crc, true);
      centralView.setUint32(20, dataBytes.length, true);
      centralView.setUint32(24, dataBytes.length, true);
      centralView.setUint16(28, nameBytes.length, true);
      centralView.setUint16(30, 0, true);
      centralView.setUint16(32, 0, true);
      centralView.setUint16(34, 0, true);
      centralView.setUint16(36, 0, true);
      centralView.setUint16(38, 0, true);
      centralView.setUint32(42, offset, true);
      const centralRecord = concatUint8([centralHeader, nameBytes]);
      centralParts.push(centralRecord);

      offset += localRecord.length;
    });

    const centralDir = concatUint8(centralParts);
    const localData = concatUint8(localParts);
    const endHeader = new Uint8Array(22);
    const endView = new DataView(endHeader.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, entries.length, true);
    endView.setUint16(10, entries.length, true);
    endView.setUint32(12, centralDir.length, true);
    endView.setUint32(16, localData.length, true);
    endView.setUint16(20, 0, true);

    return concatUint8([localData, centralDir, endHeader]);
  }

  function parseZip(buffer) {
    const data = toUint8(buffer);
    const view = new DataView(data.buffer);
    let index = data.length - 22;
    while (index >= 0 && view.getUint32(index, true) !== 0x06054b50) {
      index -= 1;
    }
    if (index < 0) {
      throw new Error('无法解析 Excel 文件（缺少 ZIP 目录）');
    }
    const endView = new DataView(data.buffer, index, 22);
    const centralOffset = endView.getUint32(16, true);
    const centralSize = endView.getUint32(12, true);
    const entriesCount = endView.getUint16(8, true);
    const entries = {};
    let pointer = centralOffset;
    for (let i = 0; i < entriesCount; i += 1) {
      const signature = view.getUint32(pointer, true);
      if (signature !== 0x02014b50) {
        break;
      }
      const nameLength = view.getUint16(pointer + 28, true);
      const extraLength = view.getUint16(pointer + 30, true);
      const commentLength = view.getUint16(pointer + 32, true);
      const localHeaderOffset = view.getUint32(pointer + 42, true);
      const nameStart = pointer + 46;
      const nameBytes = data.slice(nameStart, nameStart + nameLength);
      const name = decodeUTF8(nameBytes);
      const localHeaderView = new DataView(data.buffer, localHeaderOffset, 30);
      const localNameLength = localHeaderView.getUint16(26, true);
      const dataLength = localHeaderView.getUint32(18, true);
      const dataStart = localHeaderOffset + 30 + localNameLength;
      const fileBytes = data.slice(dataStart, dataStart + dataLength);
      entries[name] = fileBytes;
      pointer += 46 + nameLength + extraLength + commentLength;
    }
    return entries;
  }

  function columnLetter(index) {
    let value = index;
    let letters = '';
    while (value >= 0) {
      letters = String.fromCharCode((value % 26) + 65) + letters;
      value = Math.floor(value / 26) - 1;
    }
    return letters;
  }

  function columnIndex(cellRef) {
    const match = /([A-Z]+)/.exec(cellRef || '');
    if (!match) return 0;
    const letters = match[1];
    let value = 0;
    for (let i = 0; i < letters.length; i += 1) {
      value *= 26;
      value += letters.charCodeAt(i) - 64;
    }
    return value - 1;
  }

  function escapeXml(value) {
    return String(value).replace(/[&<>"']/g, ch => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&apos;'
    }[ch] || ch));
  }

  function sheetToXml(sheet) {
    const rows = sheet.__rows || [];
    const lines = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">',
      '<sheetData>'];
    rows.forEach((row, rowIndex) => {
      const cells = [];
      row.forEach((value, colIndex) => {
        const cellRef = `${columnLetter(colIndex)}${rowIndex + 1}`;
        if (value === undefined || value === null || value === '') {
          cells.push(`<c r="${cellRef}"/>`);
          return;
        }
        const numValue = Number(value);
        if (!Number.isNaN(numValue) && value !== '') {
          cells.push(`<c r="${cellRef}" t="n"><v>${numValue}</v></c>`);
        } else {
          cells.push(`<c r="${cellRef}" t="inlineStr"><is><t>${escapeXml(value)}</t></is></c>`);
        }
      });
      lines.push(`<row r="${rowIndex + 1}">${cells.join('')}</row>`);
    });
    lines.push('</sheetData></worksheet>');
    return lines.join('');
  }

  function xmlToSheet(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'application/xml');
    const sheetData = doc.getElementsByTagName('sheetData')[0];
    const rows = [];
    if (!sheetData) return { __rows: [] };
    const rowNodes = sheetData.getElementsByTagName('row');
    for (let i = 0; i < rowNodes.length; i += 1) {
      const rowNode = rowNodes[i];
      const rowIndex = Number(rowNode.getAttribute('r')) || i + 1;
      const row = [];
      const cells = rowNode.getElementsByTagName('c');
      for (let j = 0; j < cells.length; j += 1) {
        const cell = cells[j];
        const ref = cell.getAttribute('r') || `${columnLetter(j)}${rowIndex}`;
        const colIndex = columnIndex(ref);
        const type = cell.getAttribute('t');
        let value = '';
        if (type === 'inlineStr') {
          const text = cell.getElementsByTagName('t')[0];
          value = text ? text.textContent : '';
        } else {
          const v = cell.getElementsByTagName('v')[0];
          value = v ? v.textContent : '';
        }
        row[colIndex] = value;
      }
      rows[rowIndex - 1] = row;
    }
    const normalized = rows.map(row => row || []);
    return { __rows: normalized };
  }

  function jsonToSheet(data) {
    if (!Array.isArray(data) || !data.length) {
      return { __rows: [] };
    }
    const headers = [];
    const seen = new Set();
    data.forEach(item => {
      Object.keys(item).forEach(key => {
        if (!seen.has(key)) {
          seen.add(key);
          headers.push(key);
        }
      });
    });
    const rows = [headers];
    data.forEach(item => {
      const row = headers.map(key => item[key] === undefined ? '' : item[key]);
      rows.push(row);
    });
    return { __rows: rows };
  }

  function sheetToJson(sheet, opts = {}) {
    const rows = sheet.__rows || [];
    if (!rows.length) return [];
    const headers = rows[0];
    const defval = Object.prototype.hasOwnProperty.call(opts, 'defval') ? opts.defval : '';
    const result = [];
    for (let i = 1; i < rows.length; i += 1) {
      const row = rows[i] || [];
      const obj = {};
      headers.forEach((header, index) => {
        if (!header) return;
        const value = row[index];
        obj[header] = value === undefined || value === null || value === '' ? defval : value;
      });
      result.push(obj);
    }
    return result;
  }

  function bookNew() {
    return { SheetNames: [], Sheets: {} };
  }

  function bookAppendSheet(workbook, sheet, name) {
    const sheetName = name || `Sheet${workbook.SheetNames.length + 1}`;
    workbook.SheetNames.push(sheetName);
    workbook.Sheets[sheetName] = sheet;
  }

  function buildPackage(workbook) {
    const entries = [];
    const sheetNames = workbook.SheetNames;
    const sheetFiles = [];
    sheetNames.forEach((name, index) => {
      const sheet = workbook.Sheets[name];
      const sheetXml = sheetToXml(sheet);
      const fileName = `xl/worksheets/sheet${index + 1}.xml`;
      sheetFiles.push({ name: fileName, data: sheetXml });
    });

    const workbookXmlLines = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">',
      '<sheets>'];
    sheetNames.forEach((name, index) => {
      workbookXmlLines.push(`<sheet name="${escapeXml(name)}" sheetId="${index + 1}" r:id="rId${index + 1}"/>`);
    });
    workbookXmlLines.push('</sheets></workbook>');

    const contentTypeLines = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">',
      '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>',
      '<Default Extension="xml" ContentType="application/xml"/>',
      '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>'];
    sheetNames.forEach((name, index) => {
      contentTypeLines.push(`<Override PartName="/xl/worksheets/sheet${index + 1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`);
    });
    contentTypeLines.push('<Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>');
    contentTypeLines.push('<Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>');
    contentTypeLines.push('</Types>');

    const rels = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">',
      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>',
      '</Relationships>'];

    const workbookRelsLines = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'];
    sheetNames.forEach((name, index) => {
      workbookRelsLines.push(`<Relationship Id="rId${index + 1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${index + 1}.xml"/>`);
    });
    workbookRelsLines.push('</Relationships>');

    const now = new Date();
    const iso = now.toISOString();
    const coreProps = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">',
      '<dc:creator>DownEcho</dc:creator>',
      `<dcterms:created xsi:type="dcterms:W3CDTF">${iso}</dcterms:created>`,
      `<dcterms:modified xsi:type="dcterms:W3CDTF">${iso}</dcterms:modified>`,
      '</cp:coreProperties>'];

    const appProps = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
      '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">',
      '<Application>DownEcho</Application>',
      '</Properties>'];

    entries.push({ name: '[Content_Types].xml', data: contentTypeLines.join('') });
    entries.push({ name: '_rels/.rels', data: rels.join('') });
    entries.push({ name: 'xl/workbook.xml', data: workbookXmlLines.join('') });
    entries.push({ name: 'xl/_rels/workbook.xml.rels', data: workbookRelsLines.join('') });
    entries.push({ name: 'docProps/core.xml', data: coreProps.join('') });
    entries.push({ name: 'docProps/app.xml', data: appProps.join('') });
    sheetFiles.forEach(file => entries.push(file));
    return createZip(entries);
  }

  function writeFile(workbook, filename) {
    const zipData = buildPackage(workbook);
    const blob = new Blob([zipData], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'workbook.xlsx';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }

  function read(data, opts = {}) {
    let buffer;
    if (opts.type === 'array' || data instanceof ArrayBuffer || data instanceof Uint8Array) {
      buffer = data instanceof Uint8Array ? data.buffer.slice(0) : data;
    } else if (opts.type === 'binary' && typeof data === 'string') {
      const len = data.length;
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i += 1) {
        arr[i] = data.charCodeAt(i) & 0xff;
      }
      buffer = arr.buffer;
    } else {
      throw new Error('不支持的读取类型');
    }
    const entries = parseZip(buffer);
    const workbook = bookNew();
    const workbookXmlBytes = entries['xl/workbook.xml'];
    if (!workbookXmlBytes) {
      throw new Error('Excel 文件缺少 workbook 定义');
    }
    const workbookXml = decodeUTF8(workbookXmlBytes);
    const parser = new DOMParser();
    const doc = parser.parseFromString(workbookXml, 'application/xml');
    const sheetNodes = doc.getElementsByTagName('sheet');
    for (let i = 0; i < sheetNodes.length; i += 1) {
      const node = sheetNodes[i];
      const name = node.getAttribute('name') || `Sheet${i + 1}`;
      const relId = node.getAttributeNS('http://schemas.openxmlformats.org/officeDocument/2006/relationships', 'id');
      const target = `xl/worksheets/sheet${i + 1}.xml`;
      const sheetBytes = entries[target];
      if (!sheetBytes) continue;
      const sheet = xmlToSheet(decodeUTF8(sheetBytes));
      bookAppendSheet(workbook, sheet, name);
    }
    return workbook;
  }

  const XLSX = {
    utils: {
      json_to_sheet: jsonToSheet,
      sheet_to_json: sheetToJson,
      book_new: bookNew,
      book_append_sheet: bookAppendSheet
    },
    writeFile,
    read,
    version: '0.1.0-mini'
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = XLSX;
  }
  global.XLSX = XLSX;
}(typeof window !== 'undefined' ? window : globalThis));
